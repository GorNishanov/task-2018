
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta charset="utf-8">
<title>Add coroutine task type</title>
<style type="text/css">
p {text-align:justify}
li {text-align:justify}
blockquote.note
{
background-color:#E0E0E0;
padding-left: 15px;
padding-right: 15px;
padding-top: 1px;
padding-bottom: 1px;
}
ins {background-color:#A0FFA0}
del {background-color:#FFA0A0}
table {border-collapse: collapse;}
table, th, td {
border: 1px solid black;
border-collapse: collapse;
} 
</style>
</head>
<body>
<table>
<tr>
<td align="left">Doc. no.</td>
<td align="left">D1056r0</td>
</tr>
<tr>
<td align="left">Revises</td>
<td align="left">none</td>
</tr>
<tr>
<td align="left">Date:</td>
<td align="left">2018-03-23
</td>
</tr>
<!--
<tr>
<td align="left">Project:</td>
<td align="left">Programming Language C++</td>
</tr>
<tr>
<td align="left">Reference:</td>
<td align="left">ISO/IEC TS 22277, C++ Extensions for Coroutines</td>
</tr>
-->
<tr>
<td align="left">Audience:</td>
<td align="left">SG1/LEWG</td>
</tr>
<tr>
<td align="left">Reply to:</td>
<td align="left">Lewis Baker &lt;<a href="mailto:LewisBaker@gmail.com">LewisBaker@gmail.com</a>&gt;, Gor Nishanov &lt;<a href="mailto:gorn@microsoft.com">gorn@microsoft.com</a>&gt;</td>
</tr>
</table>
<h1>Add coroutine task type</h1>
<h2>Overview</h2>
<p>
The coroutines TS has introduced a language capability that allows functions to be
suspended and later resumed. One of the key applications for this new feature is to make
it easier to write asynchronous code. However, the coroutines TS itself does not (yet) 
provide any types that directly support writing asynchronous code.
</p>
<p>
This paper proposes adding a new type, std::task&lt;T&gt;, to the standard library
to enable creation and composition of coroutines representing asynchronous computation. 

<!-- 
Similar to the std::future&gt;T&lt; type, the task&lt;T&gt; type represents an operation
that produces a either a single value or an exception asynchronously.
However, unlike std::future&gt;T&gt; that -->
</p>
<!--
<p>
Unlike std::future&lt;T&gt;, the std::task&lt;T&gt; type does not provide a 
publicly accessible promise object that can be used to produce the result. 
Instead, the result is produced by a coroutine function whose body eventually
executes a co_return statement or that completes with an unhandled exception.
</p>
-->
<pre>
  #include &lt;experimental/task&gt;
  #include &lt;string&gt;
  
  struct record
  {
    int id;
    std::string name;
    std::string description;
  };
  
  std::task&lt;record&gt; load_record(int id);
  std::task&lt;&gt; save_record(record r);
  
  std::task&lt;void&gt; modify_record()
  {
    record r = co_await load_record(123);
    r.description = “Look, ma, no blocking!”;
    co_await save_record(std::move(r));
  }
</pre>
<p>
  The interface of task is intentionally minimalistic and designed 
  for efficiency. In fact, the only operation you can do with the task
  is to await on it.
  <pre>
    template &lt;typename T&gt;
    class [[nodiscard]] task {
    public:
      task(task&amp;&amp; rhs) noexcept;
      ~task();
      auto operator co_await(); <i>// exposition only</i>
    };      
  </pre>
  <!--
  In the following sections, we will go over some of the (possibly) unorthorox decisions at first, they were 
  chosen to make using tasks safer and to guide us
  -->
</p>
<h2>Why not use futures with future.then?</h2>
<p>
  The <code>std::future</code> type is inherently inefficient and cannot be used
  for efficient composition of asynchronous operations. The unavoidable cost overhead
  of the futures is due to:
  <ul>
    <li>allocation/deallocation shared state object</li>
    <li>atomic increment/decrement for managing the shared state</li>
    <li>synchronization between setting of the state and getting the value</li>
    <li>(with .then) scheduling overhead of executing subscribers to .then</li>
  </ul>
</p>
<p>
   Consider the following example:
   <pre>
      task&lt;int&gt; coro() {
        int result = 0;
        while (int v = co_await async_read())
          result += v;
        co_return result;
      }    
  </pre>
  where <code>async_read()</code> is some asynchronous operation that takes say 4ns to 
  perform. Let's say, we would like to factor out the logic into two 
  coroutines:
  <pre>
      task<int> subtask() { co_return co_await async_read(); }
        
      task&lt;int&gt; coro_refactored() {
        int result = 0;
        while (int v = co_await subtask())
          result += v;
        co_return result;
      }    
  </pre>
  Though, in this example, breaking a single `co_await` into its own function may
  seem silly, it is a useful approach to measure the overhead of composition of
  tasks. With proposed task, our per operation cost grew from 4ns to 6ns and 
  did not incur any heap allocations. Moreover, this overhead of 2ns is not 
  inherent to the task and we can anticipate that with improved coroutine
  optimization technologies we will be able to drive the overhead to be close to 0.
</p>
<p>To estimate the cost of composition with <code>std::future</code>, we used
  the following:
  <pre>
      int fut_test() {
        int count = 1'000'000;
        int result = 0;
      
        while (count > 0) {
          promise<int> p;
          auto fut = p.get_future();
          p.set_value(count--);
          result += fut.get();
        }
        return result;
      }
  </pre>
  As measure on the same system (Linux, clang 6.0, libc++), we get <b>133ns</b> per operation!  
</p>
Here is the visual illustration.
<pre>
          op cost: ****
    task overhead: **
  future overhead: **********************************************************************************************************************************
</pre>

<h2>Wording</h2>
<h3>21.11 Coroutine support library [support.coroutine] </h3>
Add the following concept definitions to synopsis of header &lt;experimental/coroutine&gt;

<blockquote>
<pre>
  <em>// 21.11.6 Awaitable concepts</em>
  template &lt;typename A&gt;
  bool concept SimpleAwaitable = <em>see below</em>;
  
  template &lt;typename A&gt;
  bool concept Awaitable = <em>see below</em>;
</pre>
</blockquote>

<blockquote>
<pre>
</pre>  
</blockquote>

<h3>21.11.6 <code>Awaitable</code> concepts [support.awaitable.simple] </h3>

<ol>
<li>
The <code>Awaitable</code> and <code>SimpleAwaitable</code> concepts specify 
the requirements on a type that is usable in an <em>await-expression</em> (8.3.8).
    
<blockquote>
<pre>
template &lt;typename T&gt;
bool concept __HasMemberOperatorCoawait = <em>// exposition only </em>
  requires(T a) { requires SimpleAwaitable<decltype(a.operator co_await())>; };          

template &lt;typename T&gt;
bool concept __HasNonMemberOperatorCoawait = <em>// exposition only </em>
  requires(T a) { requires SimpleAwaitable<decltype(operator co_await(a))>; };          

template &lt;typename A&gt;
bool concept SimpleAwaitable = requires(A a, coroutine_handle&lt;&gt; h) {
  { a.await_ready() } -&gt; bool;
  a.await_resume();
  a.await_suspend(h);
};          
      
template &lt;typename A&gt;
bool concept Awaitable = __HasMemberOperatorCoawait&lt;A&gt;
  || __HasNonMemberOperatorCoawait&lt;A&gt; || SimpleAwaitable&lt;A&gt;;
</pre>  
</blockquote>
</li>
<li>
  If the type of an expression <em>E</em> satisfies the <code>Awaitable</code>
  concept then the term <em>simple awaitable of E</em> refers to an object
  satisfying <code>SimpleAwaitable</code> concept that is either the result 
  of <em>E</em> or the result of an application of <code>operator co_await</code>
  to the result of <em>E</em>.
</li>
</li>
</ol>

<h3>XX.1 Coroutines tasks [coroutine.task]</h3>
<h4>XX.1.1 Overview [coroutine.task.overview]</h4>
<ol><li>
  This subclause describes components that a C++ program can use to create
  coroutines representing asynchronous computations. 
</li></ol>
<h4>XX.1.2 Header <code>task</code> synopsis [coroutine.task.syn]</h4>
<blockquote>
<pre>
namespace std::experimental {
inline namespace coroutines_v1 {

template&lt;typename T = void&gt; class task;
template&lt;typename T&gt; class task&lt;T&amp;&gt;;
template&lt;&gt; class task&lt;void&gt;;

} <em>// namespace coroutines_v1</em>
} <em>// namespace std::experimental</em>
</pre>
</blockquote>
<ol><li>
  what now?
</li></ol>
<h3>XX.YY.1 Class template <code>task</code> [coroutine.task.task]</h3>
<ol>
  <pre>
  template &lt;typename T&gt;
  class [[nodiscard]] task {
  public:
    task(task&amp;&amp; rhs) noexcept;
    ~task();
    auto operator co_await(); <i>// exposition only</i>
  private:
    coroutine_handle&lt;<em>unspecified</em>&gt; h; <i>// exposition only</i>
  };      
</pre>
    <li>
    The class template <code>task</code> defines a type for a 
    <em>coroutine task object</em> that can be associated with a
    coroutine which return type is <code>task&lt;<em>T</em>&gt;</code>
    for some type <em>T</em>. In this subclause, we will refer to such a coroutine as 
    <em>task coroutine</em> and to type <em>T</em> as <em>eventual type</em>
    of a coroutine.  The implementation shall define class template <code>task</code> and provide
    and two specializations, task&lt;&amp;T&gt; and task&lt;void&gt;.
    </li>
    <br>
    <li>
    The implementation shall provide specializations of <code>coroutine_traits</code>
    as required to implement the following behavior:
    <p>
    <ol type="I">
      <li>
        A call to a task coroutine <em>f</em>
        shall return a task object <em>t</em> associated with 
        that coroutine. The called coroutine must be suspended 
        at the initial suspend point (11.4.4).
        Such task object is considered to be in the <em>armed</em> state.        
      </li>
      <br>
      <li>
        A type of a task object shall satisfy the <code>Awaitable</code> concept and
        awaiting on a task object in the <em>armed</em> state as 
        if by <code>co_await<em>t</em></code> (8.3.8) shall register the
        awaiting coroutine <em>a</em> with task object <em>t</em> 
        and resume the coroutine <em>f</em>.
        At this point task object <em>t</em>
        is considered to be in a <em>launched</em> state. Awaiting on a task object
        that is not in the <em>armed</em> state has undefined behavior.
      </li>
      <br>
      <li>        
        Let <em>sa</em> be a simple awaitable of <em>t</em> (21.11.6).
        If coroutine <em>f</em> completes due to execution of
        a <em>coroutine return statement</em> (9.6.3) or an unhandled
        exception leaving the user-authored body of the coroutine,
        awaiting coroutine <em>a</em> is resumed and an expression
        <code><em>sa</em>.await_resume()</code>
        shall evaluate to the operand of <code>co_return</code> 
        statement in coroutine <em>f</em>, or shall throw the exception, respectively. 
      </li>
      <br>
      <li>
        If in the definition of the coroutine <em>g</em>, the first parameter has type
        <code>allocator_arg_t</code>, then the coroutine must have at least two arguments
        and the type of the second parameter shall satisfy the <code>Allocator</code> 
        requirements (Table 31) and if dynamic allocation required to store 
        the coroutine state (11.4.4), implementation should use provided allocator to
        allocate and deallocate the coroutine state.
      </li>
      <br>
      <li>
        If <em>yield-expression</em> (8.20) occurs in the suspension context of
        the task coroutine, the program is ill-formed.
      </li>
    </ol>
    </p>
  </ol>
<h5>XX.YY.1.1 constructor</h5>
<pre>
  task(task&amp;&amp; rhs) noexcept;
</pre>
  <li>
    <em>Effects:</em> Move constructs a <code>task</code> object that refers
    to the coroutine that was originally referred to by <code>rhs</code> (if any).
  </li>
  <li>
    <em>Postcondition:</em> <code>rhs</code> is empty.
  </li>
<h5>XX.YY.1.2 destructor</h5>
<pre>  ~task();  </pre>
  <ol>
    <li>
      <em>Requires:</em> the coroutine referred to by the <code>task</code> object
      (if any) must be suspended.
    </li>
    <li>
      <em>Effects:</em> Move constructs a <code>task</code> object that refers
      to the coroutine that was originally referred to by <code>rhs</code> (if any).
    </li>
    <li>
      <em>Postcondition:</em> Referred to coroutine (if any) is destroyed.
      <em>[Note: </em> A resumption of a destroyed coroutine
       results in undefined behavior <em>-- end note]</em>
    </li>
  </ol>
  
</body>
</html>
